package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"os/exec"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"

	"github.com/lovung/wrappergen/internal"
)

const wrapperTemplate = `// Code generated by go generate; DO NOT EDIT.
package {{ .PackageName }}

import (
	%s
)

{{ range $i := .Interfaces}}
type {{ $.WrapperPrefix }}{{ .Name }}{{ $.WrapperSuffix }} struct {
	inner {{ .Name }}
}

func New{{ $.WrapperPrefix }}{{ .Name }}{{ $.WrapperSuffix }}(inner {{ .Name }}) {{ .Name }} {
	return &{{ $.WrapperPrefix }}{{ .Name }}{{ $.WrapperSuffix }}{
		inner: inner,
	}
}

{{ range .Methods }}
func (w *{{ $.WrapperPrefix }}{{ $i.Name }}{{ $.WrapperSuffix }}) {{ .Name }}(
	{{ .Params }}) (
	{{ .Return }}) {
	// Start of customize code
	%s
	// End of customize code

	return w.inner.{{ .Name }}({{ .Args }})
}
{{ end }}
{{ end }}
`

type Config struct {
	PackagePath       string
	ExcludeFiles      []string
	ExcludeInterfaces []string
	CustomCode        string
	CustomImports     string

	WrapperPrefix string
	WrapperSuffix string
	// TODO: Support ignore method
	// IgnoreInterfaceMethods []string
}

type Interface struct {
	Name    string
	Methods []*internal.Method
}

type TemplateData struct {
	PackageName   string
	WrapperPrefix string
	WrapperSuffix string
	Interfaces    []*Interface
}

// Custom flag type for string slices
type stringSliceFlag []string

func (ss *stringSliceFlag) String() string {
	return fmt.Sprintf("%v", *ss)
}

func (ss *stringSliceFlag) Set(value string) error {
	*ss = append(*ss, strings.Split(value, ",")...)
	return nil
}

func buildConfigFromFlags() *Config {
	config := &Config{}

	// Command-line flags
	flag.StringVar(&config.PackagePath, "package_path", "", "Package path")
	flag.StringVar(&config.WrapperPrefix, "wrapper_prefix", "", "Wrapper prefix")
	flag.StringVar(&config.WrapperSuffix, "wrapper_suffix", "Wrapper", "Wrapper suffix")
	flag.StringVar(&config.CustomCode, "custom_code", "", "Wrapper prefix")
	if len(config.CustomCode) == 0 {
		if customCode := os.Getenv("CUSTOM_CODE"); customCode != "" {
			config.CustomCode = customCode
		}
	}
	flag.StringVar(&config.CustomImports, "custom_imports", "", "Wrapper suffix")
	if len(config.CustomImports) == 0 {
		if customImports := os.Getenv("CUSTOM_IMPORTS"); customImports != "" {
			config.CustomImports = customImports
		}
	}

	// Use a custom flag type for slices
	var excludeFiles, excludeInterfaces stringSliceFlag
	flag.Var(&excludeFiles, "exclude_files", "Comma-separated list of file names to ignore")
	flag.Var(&excludeInterfaces, "exclude_interfaces", "Comma-separated list of interface names to ignore")

	// Parse flags
	flag.Parse()

	// Convert the string slices to []string
	config.ExcludeFiles = excludeFiles
	config.ExcludeInterfaces = excludeInterfaces

	return config
}

func getPackagePathFromCwd() string {
	// Get the current working directory
	cwd, err := os.Getwd()
	if err != nil {
		fmt.Println("Error getting current working directory:", err)
		os.Exit(1)
	}

	// Use the "go list" command to get the package name
	cmd := exec.Command("go", "list", ".")
	cmd.Dir = cwd
	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Println("Error running 'go list .':", err)
		os.Exit(1)
	}

	// Extract the package name from the output
	packagePath := strings.TrimSpace(string(output))

	fmt.Println("Package path:", packagePath)
	return packagePath
}

func main() {
	cfg := buildConfigFromFlags()

	if cfg.PackagePath == "" {
		cfg.PackagePath = getPackagePathFromCwd()
	}

	generator := internal.NewWrapperGenerator(cfg.PackagePath,
		internal.WithIgnoreFileNames(cfg.ExcludeFiles),
		internal.WithIgnoreInterfaceNames(cfg.ExcludeInterfaces),
	)

	packageName, interfaces, err := generator.ParseData()
	if err != nil {
		log.Fatal(err)
	}

	genDataInterfaces := make([]*Interface, 0, len(interfaces))
	for _, iface := range interfaces {
		genDataInterfaces = append(genDataInterfaces, &Interface{
			Name:    iface.Name,
			Methods: iface.Methods,
		})
	}

	data := TemplateData{
		PackageName:   packageName,
		WrapperPrefix: cfg.WrapperPrefix,
		WrapperSuffix: cfg.WrapperSuffix,
		Interfaces:    genDataInterfaces,
	}

	generatedCode, err := generateWrapperCode(data, cfg)
	if err != nil {
		log.Println(data)
		log.Fatal(err)
	}

	formattedCode, err := format.Source(generatedCode)
	if err != nil {
		fmt.Println("Formatted Code:", string(generatedCode))
		log.Fatal(err)
	}

	formattedCode, err = imports.Process("", formattedCode, nil)
	if err != nil {
		fmt.Println("Formatted Code:", string(formattedCode))
		log.Fatal(err)
	}

	// Save the generated code to a new file
	outputFileName := packageName + ".wrapper.gen.go"
	if err := saveToFile(outputFileName, formattedCode); err != nil {
		log.Fatal(err)
	}

	fmt.Println("Generated code saved to", outputFileName)
}

// saveToFile saves content to a file with the given filename.
func saveToFile(filename string, content []byte) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.Write(content)
	return err
}

func generateWrapperCode(data TemplateData, cfg *Config) ([]byte, error) {
	wrapperTemplate := fmt.Sprintf(wrapperTemplate, cfg.CustomImports, cfg.CustomCode)

	tmpl, err := template.New("first").Parse(wrapperTemplate)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}
